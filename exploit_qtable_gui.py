import chess
import chess.svg
import chess.engine
import json
import random
import time
import threading

from PyQt5.QtSvg import QSvgWidget
from PyQt5.QtWidgets import (QApplication, QWidget, QPushButton, QVBoxLayout, QHBoxLayout, 
                             QLabel, QTextEdit, QMessageBox, QGroupBox, QFrame, QScrollArea)
from PyQt5.QtCore import QTimer, pyqtSignal, QThread
from states.QTable import QTable
from states.state_KRvsk import State

engine_path = "stockfish/stockfish-windows-x86-64-avx2.exe"


class GameThread(QThread):
    move_played = pyqtSignal(str, str)  # Signal for move played (player, move)
    game_over = pyqtSignal(str)  # Signal for game over (result)
    
    def __init__(self, qtable, engine, use_stockfish=True):
        super().__init__()
        self.qtable = qtable
        self.engine = engine
        self.use_stockfish = use_stockfish
        self.board = None
        self.running = False
        
    def start_game(self, initial_fen):
        self.board = chess.Board(initial_fen)
        self.running = True
        self.start()
        
    def stop_game(self):
        self.running = False
        
    def run(self):
        if not self.board:
            return
            
        while self.running and not self.board.is_game_over():
            if self.board.turn == chess.WHITE:
                # Q-table move (White)
                fen = self.board.fen().split(' ')[0]
                legal_moves = [move.uci() for move in self.board.legal_moves]
                
                if fen in self.qtable.q_table:
                    # Pick the best move from Q-table
                    best_move = self.qtable.argmax(fen)
                    if best_move:
                        # Convert algebraic to UCI
                        uci_move = self.algebraic_to_uci(best_move)
                        if uci_move in legal_moves:
                            move = chess.Move.from_uci(uci_move)
                            self.board.push(move)
                            self.move_played.emit("Q-Table", f"{best_move} ({uci_move})")
                        else:
                            # Fallback to random move
                            move = random.choice(list(self.board.legal_moves))
                            self.board.push(move)
                            self.move_played.emit("Q-Table (Random)", str(move))
                    else:
                        # Fallback to random move
                        move = random.choice(list(self.board.legal_moves))
                        self.board.push(move)
                        self.move_played.emit("Q-Table (Random)", str(move))
                else:
                    # Random move if state not in Q-table
                    move = random.choice(list(self.board.legal_moves))
                    self.board.push(move)
                    self.move_played.emit("Q-Table (Random)", str(move))
            else:
                # Black move (Stockfish or Random)
                if self.use_stockfish and self.engine:
                    try:
                        result = self.engine.play(self.board, chess.engine.Limit(time=0.1))
                        if result.move:
                            self.board.push(result.move)
                            self.move_played.emit("Stockfish", str(result.move))
                        else:
                            move = random.choice(list(self.board.legal_moves))
                            self.board.push(move)
                            self.move_played.emit("Stockfish (Random)", str(move))
                    except Exception as e:
                        move = random.choice(list(self.board.legal_moves))
                        self.board.push(move)
                        self.move_played.emit("Stockfish (Error)", str(move))
                else:
                    # Random move
                    move = random.choice(list(self.board.legal_moves))
                    self.board.push(move)
                    self.move_played.emit("Random", str(move))
            
            # Small delay to make moves visible
            self.msleep(500)
            
        if self.board.is_game_over():
            result = self.board.result()
            self.game_over.emit(result)
    
    def algebraic_to_uci(self, algebraic_move):
        """Convert algebraic notation to UCI"""
        if len(algebraic_move) >= 3:
            piece = algebraic_move[0]
            target = algebraic_move[1:3]
            
            # Find the source square for the piece
            for square in chess.SQUARES:
                piece_at_square = self.board.piece_at(square)
                if piece_at_square and piece_at_square.symbol() == piece:
                    source = chess.square_name(square)
                    return source + target
        
        return algebraic_move


class MainWindow(QWidget):
    def __init__(self):
        super().__init__()

        self.setGeometry(100, 100, 1200, 800)
        self.setWindowTitle("Chess Endgame Q-Table vs Opponent")

        # Initialize game variables
        self.qtable = None
        self.engine = None
        self.game_thread = None
        self.move_history = []
        self.use_stockfish = True  # Default to using Stockfish
        
        # Load Q-table
        self.load_qtable()
        
        # Setup Stockfish engine
        self.setup_engine()
        
        # Setup UI
        self.setup_ui()
        
        # Initialize board
        initial_fen = State.random_kr_vs_k_fen()
        self.chessboard = chess.Board(initial_fen)
        
        # Setup update timer
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.update_board_display)
        self.update_timer.start(100)  # Update every 100ms
        
        self.update_board_display()

    def load_qtable(self):
        try:
            with open("results/test_trained_qtable.json") as f:
                qtable_data = json.load(f)
            self.qtable = QTable(qtable_data)
            print("Q-table loaded successfully")
            # Update Q-table status
            if hasattr(self, 'qtable_status_label'):
                self.qtable_status_label.setText("Q-Table: Loaded")
                self.qtable_status_label.setStyleSheet("""
                    QLabel {
                        background-color: #27ae60;
                        color: white;
                        font-weight: bold;
                        font-size: 12px;
                        padding: 6px;
                        border-radius: 5px;
                        border: 1px solid #229954;
                    }
                """)
        except FileNotFoundError:
            print("Q-table file not found!")
            self.qtable = QTable({})
            if hasattr(self, 'qtable_status_label'):
                self.qtable_status_label.setText("Q-Table: Not Found")
                self.qtable_status_label.setStyleSheet("""
                    QLabel {
                        background-color: #e74c3c;
                        color: white;
                        font-weight: bold;
                        font-size: 12px;
                        padding: 6px;
                        border-radius: 5px;
                        border: 1px solid #c0392b;
                    }
                """)
        except json.JSONDecodeError as e:
            print(f"JSON error: {e}")
            self.qtable = QTable({})
            if hasattr(self, 'qtable_status_label'):
                self.qtable_status_label.setText("Q-Table: Error")
                self.qtable_status_label.setStyleSheet("""
                    QLabel {
                        background-color: #e74c3c;
                        color: white;
                        font-weight: bold;
                        font-size: 12px;
                        padding: 6px;
                        border-radius: 5px;
                        border: 1px solid #c0392b;
                    }
                """)
    
    def setup_engine(self):
        try:
            # Update the engine path to the correct path
            self.engine = chess.engine.SimpleEngine.popen_uci(engine_path)
            print("Stockfish engine loaded successfully")
        except Exception as e:
            print(f"Failed to load Stockfish engine: {e}")
            self.engine = None

    def setup_ui(self):
        layout = QVBoxLayout()
        
        # Top panel with buttons
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        
        # Button styling
        button_style = """
            QPushButton {
                background-color: #3498db;
                color: white;
                border: none;
                padding: 10px 20px;
                font-size: 12px;
                font-weight: bold;
                border-radius: 6px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #2980b9;
            }
            QPushButton:pressed {
                background-color: #21618c;
            }
            QPushButton:disabled {
                background-color: #bdc3c7;
                color: #7f8c8d;
            }
        """
        
        self.new_game_btn = QPushButton("New Game")
        self.new_game_btn.setStyleSheet(button_style)
        self.new_game_btn.clicked.connect(self.new_game)
        button_layout.addWidget(self.new_game_btn)
        
        self.start_game_btn = QPushButton("Start vs Stockfish")
        self.start_game_btn.setStyleSheet(button_style)
        self.start_game_btn.clicked.connect(self.start_game)
        button_layout.addWidget(self.start_game_btn)
        
        self.toggle_opponent_btn = QPushButton("Toggle: Stockfish")
        self.toggle_opponent_btn.setStyleSheet("""
            QPushButton {
                background-color: #9b59b6;
                color: white;
                border: none;
                padding: 10px 20px;
                font-size: 12px;
                font-weight: bold;
                border-radius: 6px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #8e44ad;
            }
            QPushButton:pressed {
                background-color: #7d3c98;
            }
        """)
        self.toggle_opponent_btn.clicked.connect(self.toggle_opponent)
        button_layout.addWidget(self.toggle_opponent_btn)
        
        self.stop_game_btn = QPushButton("Stop Game")
        self.stop_game_btn.setStyleSheet("""
            QPushButton {
                background-color: #e74c3c;
                color: white;
                border: none;
                padding: 10px 20px;
                font-size: 12px;
                font-weight: bold;
                border-radius: 6px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #c0392b;
            }
            QPushButton:pressed {
                background-color: #a93226;
            }
            QPushButton:disabled {
                background-color: #bdc3c7;
                color: #7f8c8d;
            }
        """)
        self.stop_game_btn.clicked.connect(self.stop_game)
        self.stop_game_btn.setEnabled(False)
        button_layout.addWidget(self.stop_game_btn)
        
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("""
            QLabel {
                font-size: 14px;
                font-weight: bold;
                color: #2c3e50;
                background-color: #ecf0f1;
                padding: 8px 15px;
                border-radius: 6px;
                border: 2px solid #bdc3c7;
                min-width: 150px;
            }
        """)
        button_layout.addWidget(self.status_label)
        
        layout.addLayout(button_layout)
        
        # Main content area
        content_layout = QHBoxLayout()
        
        # Left side - Chess board
        board_layout = QVBoxLayout()
        self.widgetSvg = QSvgWidget()
        self.widgetSvg.setFixedSize(600, 600)
        board_layout.addWidget(self.widgetSvg)
        
        # Board info
        self.board_info_label = QLabel("")
        board_layout.addWidget(self.board_info_label)
        
        content_layout.addLayout(board_layout)
        
        # Right side - Game info and log
        right_panel = QFrame()
        right_panel.setFrameStyle(QFrame.StyledPanel)
        right_panel.setStyleSheet("""
            QFrame {
                background-color: #f5f5f5;
                border: 2px solid #d0d0d0;
                border-radius: 10px;
                margin: 5px;
            }
        """)
        
        info_layout = QVBoxLayout(right_panel)
        info_layout.setSpacing(15)
        info_layout.setContentsMargins(15, 15, 15, 15)
        
        # Game Status Section
        status_group = QGroupBox("Game Status")
        status_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 14px;
                color: #2c3e50;
                border: 2px solid #bdc3c7;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        status_layout = QVBoxLayout(status_group)
        status_layout.setSpacing(8)
        
        # Current turn indicator
        self.turn_indicator = QLabel("White to move")
        self.turn_indicator.setStyleSheet("""
            QLabel {
                font-size: 16px;
                font-weight: bold;
                color: #2c3e50;
                background-color: #ecf0f1;
                padding: 8px;
                border-radius: 5px;
                border: 1px solid #bdc3c7;
            }
        """)
        status_layout.addWidget(self.turn_indicator)
        
        # Game result
        self.result_label = QLabel("Result: In Progress")
        self.result_label.setStyleSheet("""
            QLabel {
                font-size: 14px;
                font-weight: bold;
                color: #e74c3c;
                background-color: #fadbd8;
                padding: 6px;
                border-radius: 5px;
                border: 1px solid #f1948a;
            }
        """)
        status_layout.addWidget(self.result_label)
        
        info_layout.addWidget(status_group)
        
        # Board Information Section
        board_info_group = QGroupBox("Board Information")
        board_info_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 14px;
                color: #2c3e50;
                border: 2px solid #bdc3c7;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        board_info_layout = QVBoxLayout(board_info_group)
        board_info_layout.setSpacing(8)
        
        # FEN display
        fen_label_title = QLabel("FEN Position:")
        fen_label_title.setStyleSheet("font-weight: bold; color: #34495e;")
        board_info_layout.addWidget(fen_label_title)
        
        self.fen_label = QLabel("8/8/8/8/8/8/8/8 w - - 0 1")
        self.fen_label.setStyleSheet("""
            QLabel {
                background-color: #2c3e50;
                color: #ecf0f1;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 8px;
                border-radius: 5px;
                border: 1px solid #34495e;
            }
        """)
        self.fen_label.setWordWrap(True)
        board_info_layout.addWidget(self.fen_label)
        
        # Last move
        last_move_title = QLabel("Last Move:")
        last_move_title.setStyleSheet("font-weight: bold; color: #34495e;")
        board_info_layout.addWidget(last_move_title)
        
        self.last_move_label = QLabel("None")
        self.last_move_label.setStyleSheet("""
            QLabel {
                background-color: #3498db;
                color: white;
                font-weight: bold;
                font-size: 12px;
                padding: 6px;
                border-radius: 5px;
                border: 1px solid #2980b9;
            }
        """)
        board_info_layout.addWidget(self.last_move_label)
        
        info_layout.addWidget(board_info_group)
        
        # Move History Section
        history_group = QGroupBox("Move History")
        history_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 14px;
                color: #2c3e50;
                border: 2px solid #bdc3c7;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        history_layout = QVBoxLayout(history_group)
        
        # Move history with scroll area
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setMaximumHeight(250)
        scroll_area.setStyleSheet("""
            QScrollArea {
                border: 1px solid #bdc3c7;
                border-radius: 5px;
                background-color: white;
            }
        """)
        
        self.move_history_text = QTextEdit()
        self.move_history_text.setReadOnly(True)
        self.move_history_text.setStyleSheet("""
            QTextEdit {
                background-color: #f8f9fa;
                border: none;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                padding: 5px;
            }
        """)
        scroll_area.setWidget(self.move_history_text)
        history_layout.addWidget(scroll_area)
        
        info_layout.addWidget(history_group)
        
        # Q-Table Information Section
        qtable_group = QGroupBox("Q-Table Status")
        qtable_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                font-size: 14px;
                color: #2c3e50;
                border: 2px solid #bdc3c7;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        qtable_layout = QVBoxLayout(qtable_group)
        
        self.qtable_status_label = QLabel("Q-Table: Loaded")
        self.qtable_status_label.setStyleSheet("""
            QLabel {
                background-color: #27ae60;
                color: white;
                font-weight: bold;
                font-size: 12px;
                padding: 6px;
                border-radius: 5px;
                border: 1px solid #229954;
            }
        """)
        qtable_layout.addWidget(self.qtable_status_label)
        
        self.qtable_info_label = QLabel("States: 0 | Actions: 0")
        self.qtable_info_label.setStyleSheet("""
            QLabel {
                background-color: #ecf0f1;
                color: #2c3e50;
                font-size: 11px;
                padding: 4px;
                border-radius: 3px;
                border: 1px solid #bdc3c7;
            }
        """)
        qtable_layout.addWidget(self.qtable_info_label)
        
        info_layout.addWidget(qtable_group)
        
        # Add stretch to push everything to the top
        info_layout.addStretch()
        
        content_layout.addWidget(right_panel)
        
        layout.addLayout(content_layout)
        self.setLayout(layout)

    def new_game(self):
        """Start a new game with random initial position"""
        try:
            # Generate new initial position
            initial_fen = State.random_kr_vs_k_fen()
            self.chessboard = chess.Board(initial_fen)
            self.move_history = []
            self.move_history_text.clear()
            
            self.update_board_display()
            self.update_info()
            self.status_label.setText("New Game Ready")
            
            print(f"New game started with FEN: {initial_fen}")
            
        except Exception as e:
            print(f"Error starting new game: {e}")
            QMessageBox.critical(self, "Error", f"Failed to start new game: {e}")

    def toggle_opponent(self):
        """Toggle between Stockfish and Random opponent"""
        self.use_stockfish = not self.use_stockfish
        
        if self.use_stockfish:
            self.toggle_opponent_btn.setText("Toggle: Stockfish")
            self.start_game_btn.setText("Start vs Stockfish")
        else:
            self.toggle_opponent_btn.setText("Toggle: Random")
            self.start_game_btn.setText("Start vs Random")
            
        print(f"Opponent mode: {'Stockfish' if self.use_stockfish else 'Random'}")

    def start_game(self):
        """Start playing against opponent (Stockfish or Random)"""
        if not self.qtable:
            QMessageBox.warning(self, "Warning", "Q-table not loaded!")
            return
            
        if self.use_stockfish and not self.engine:
            QMessageBox.warning(self, "Warning", "Stockfish engine not available!")
            return
            
        # Create and start game thread
        self.game_thread = GameThread(self.qtable, self.engine, self.use_stockfish)
        self.game_thread.move_played.connect(self.on_move_played)
        self.game_thread.game_over.connect(self.on_game_over)
        
        # Start the game
        initial_fen = self.chessboard.fen()
        self.game_thread.start_game(initial_fen)
        
        # Update UI
        self.start_game_btn.setEnabled(False)
        self.stop_game_btn.setEnabled(True)
        opponent_name = "Stockfish" if self.use_stockfish else "Random"
        self.status_label.setText(f"Playing vs {opponent_name}...")

    def stop_game(self):
        """Stop the current game"""
        if self.game_thread:
            self.game_thread.stop_game()
            self.game_thread.wait()
            self.game_thread = None
            
        self.start_game_btn.setEnabled(True)
        self.stop_game_btn.setEnabled(False)
        self.status_label.setText("Game Stopped")

    def on_move_played(self, player, move):
        """Handle when a move is played"""
        self.move_history.append(f"{player}: {move}")
        self.move_history_text.append(f"{len(self.move_history)}. {player}: {move}")
        
        # Update the main board with the current state from game thread
        if self.game_thread and self.game_thread.board:
            self.chessboard = self.game_thread.board
        
        # Update board display
        self.update_board_display()
        self.update_info()

    def on_game_over(self, result):
        """Handle when game is over"""
        self.result_label.setText(f"Result: {result}")
        self.status_label.setText(f"Game Over: {result}")
        
        # Update result label styling based on result
        if result == "1-0":
            # White wins
            self.result_label.setStyleSheet("""
                QLabel {
                    font-size: 14px;
                    font-weight: bold;
                    color: #27ae60;
                    background-color: #d5f4e6;
                    padding: 6px;
                    border-radius: 5px;
                    border: 1px solid #2ecc71;
                }
            """)
        elif result == "0-1":
            # Black wins
            self.result_label.setStyleSheet("""
                QLabel {
                    font-size: 14px;
                    font-weight: bold;
                    color: #e74c3c;
                    background-color: #fadbd8;
                    padding: 6px;
                    border-radius: 5px;
                    border: 1px solid #f1948a;
                }
            """)
        else:
            # Draw
            self.result_label.setStyleSheet("""
                QLabel {
                    font-size: 14px;
                    font-weight: bold;
                    color: #f39c12;
                    background-color: #fef9e7;
                    padding: 6px;
                    border-radius: 5px;
                    border: 1px solid #f1c40f;
                }
            """)
        
        self.start_game_btn.setEnabled(True)
        self.stop_game_btn.setEnabled(False)
        
        print(f"Game over: {result}")

    def update_board_display(self):
        """Update the chess board display"""
        # Use the most current board state
        current_board = self.chessboard
        if self.game_thread and self.game_thread.board:
            current_board = self.game_thread.board
            
        if not current_board:
            return
            
        # Generate SVG board
        self.chessboardSvg = chess.svg.board(
            current_board,
            size=600,
            coordinates=True,
            colors={
                'square light': '#f0d9b5', 
                'square dark': '#b58863',
                'margin': '#2b2b2b'
            }
        ).encode("UTF-8")
        
        # Load into widget
        self.widgetSvg.load(self.chessboardSvg)

    def update_info(self):
        """Update game information"""
        # Use the most current board state
        current_board = self.chessboard
        if self.game_thread and self.game_thread.board:
            current_board = self.game_thread.board
            
        if not current_board:
            return
            
        # Update FEN
        fen = current_board.fen()
        self.fen_label.setText(fen)
        
        # Update turn indicator
        turn_text = "White to move" if current_board.turn == chess.WHITE else "Black to move"
        self.turn_indicator.setText(turn_text)
        
        # Update last move
        if self.move_history:
            self.last_move_label.setText(self.move_history[-1])
        else:
            self.last_move_label.setText("None")
            
        # Update Q-table information
        if self.qtable and hasattr(self, 'qtable_info_label'):
            fen_key = fen.split(' ')[0]
            if fen_key in self.qtable.q_table:
                q_values = self.qtable.q_table[fen_key]
                best_action = max(q_values, key=q_values.get) if q_values else "None"
                q_info = f"States: {len(self.qtable.q_table)} | Current State: Found | Best Action: {best_action}"
            else:
                q_info = f"States: {len(self.qtable.q_table)} | Current State: Not Found | Best Action: Random"
            self.qtable_info_label.setText(q_info)

    def closeEvent(self, event):
        """Handle window closing"""
        # Stop the update timer
        if hasattr(self, 'update_timer'):
            self.update_timer.stop()
            
        if self.game_thread:
            self.game_thread.stop_game()
            self.game_thread.wait()
            
        if self.engine:
            try:
                self.engine.quit()
            except:
                pass
                
        event.accept()

if __name__ == "__main__":
    app = QApplication([])
    window = MainWindow()
    window.show()
    app.exec_()