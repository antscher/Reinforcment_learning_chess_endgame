import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from trainning.trainning_policy_gradient import Trainer
from states.state_KRvsk import State
import time
import numpy as np
import chess.engine

if __name__ == "__main__":   
    # --- Options ---
    use_stockfish = True  # Set to True to use Stockfish for black, False for random
    engine_path = "stockfish/stockfish-windows-x86-64-avx2.exe"  # Update path as needed

    trainer = Trainer()
    trainer.load('results/policy_gradient.pkl')
    test_episodes = 200

    print(f"\nTesting policy on {test_episodes} random FENs... (Black: {'Stockfish' if use_stockfish else 'Random'})")
    test_mates = 0
    test_draws = 0
    test_lengths = []


    engine = None
    if use_stockfish:
        engine = chess.engine.SimpleEngine.popen_uci(engine_path)

    for ep in range(test_episodes):
        #fen = "k7/3K4/8/8/8/3R4/8/8"
        fen = State.random_kr_vs_k_fen()
        #fen = State.random_kr_vs_k_fen()
        root_state = State()
        root_state.create_from_fen(fen)
        state = State(
            w_king=root_state.get_position('WKing'),
            w_rook=root_state.get_position('WRook'),
            b_king=root_state.get_position('BKing')
        )
        board = chess.Board(state.to_fen())
        trajectory = []
        reward = 0
        for t in range(1000):
            # White's move (policy)
            move, state_id, moves = trainer.select_action(state)
            if move is None:
                break
            board.push(move)
            state = State()
            state.create_from_fen(board.fen())
            if board.is_game_over():
                result = board.result()
                reward = 1 if result == '1-0' else 0
                trajectory.append((state_id, move, reward))
                break
            # Black's move
            if use_stockfish and engine is not None:
                result = engine.play(board, chess.engine.Limit(time=0.05))
                if result.move is not None:
                    board.push(result.move)
                else:
                    # Stockfish failed to return a move, treat as draw
                    reward = 0
                    break
            else:
                black_moves = list(board.legal_moves)
                if not black_moves:
                    break
                import random
                black_move = random.choice(black_moves)
                board.push(black_move)
            state = State()
            state.create_from_fen(board.fen())
            if board.is_game_over():
                result = board.result()
                reward = 1 if result == '1-0' else 0
                trajectory.append((state_id, move, reward))
                break
            trajectory.append((state_id, move, 0))
        # Episode summary
        if reward == 1:
            test_mates += 1
        else:
            test_draws += 1
        test_lengths.append(len(trajectory))
        print(f"Test Episode {ep+1}/{test_episodes} | Reward: {reward} | Length: {len(trajectory)}")

    if use_stockfish and engine is not None:
        engine.quit()

    print(f"\nTest results:")
    print(f"  Mates: {test_mates} ({100*test_mates/test_episodes:.1f}%)")
    print(f"  Draws: {test_draws} ({100*test_draws/test_episodes:.1f}%)")
    print(f"  Avg moves per episode: {np.mean(test_lengths):.1f}")