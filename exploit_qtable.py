import json
import random
import chess
import chess.engine
from states.QTable import QTable
from states.state_KRvsk import State

# Load the trained Q-table
try:
    with open("results/test_trained_qtable.json") as f:
        qtable_data = json.load(f)
except json.JSONDecodeError as e:
    print(f"JSON error: {e}")
    qtable_data = {}

qtable = QTable(qtable_data)

# Example: Play a game using the Q-table policy (white) vs Stockfish (black)
initial_fen = State.random_kr_vs_k_fen_column_a()
board = chess.Board(initial_fen)

print(f"Initial FEN: {initial_fen}")

# Set up Stockfish engine
engine_path = "stockfish/stockfish-windows-x86-64-avx2.exe"
engine = chess.engine.SimpleEngine.popen_uci(engine_path)

while not board.is_game_over():
    if board.turn == chess.WHITE:
        fen = board.fen().split(' ')[0]
        legal_moves = [move.uci() for move in board.legal_moves]
        if fen in qtable.q_table:
            # Pick the best move from Q-table
            best_move = qtable.argmax(fen)
            print(f"QTable move: {best_move}")
            board.push_san(best_move) # type: ignore
        else:
            # If unseen, pick a random move
            move = legal_moves[0]
            print(f"Random move: {move}")
            board.push_san(move)
    else:
        # Black (Stockfish) move
        """
        result = engine.play(board, chess.engine.Limit(time=0.1))
        if result.move is not None:
            print(f"Stockfish move: {result.move.uci()}")
            board.push(result.move)
        else:
            print("Stockfish has no legal move (None returned)")
        """
        result = random.choice([move.uci() for move in board.legal_moves])  # Random move for black
        board.push_san(result)
        print(f"Random black move: {result}")
    print(board)
    print()

engine.quit()
print(f"Game over: {board.result()}")
